\section{3-я лекция}

\subsection{Объявления, определения и области видимости}

\begin{definition}
	Объявление (declaration) - введение новой сущности (переменной, функции и т.д.)
\end{definition}

\begin{example}
	\begin{verbatim}
		int x = 5;
	\end{verbatim}
	
	\begin{verbatim}
		int main() {
			
		}
	\end{verbatim}
\end{example}

\begin{note}
	Нельзя объявлять функции внутри других функций.
\end{note}

\begin{definition}
	Определение (definition) - задать поведение или значение сущности.
\end{definition}

\begin{note}
	Для переменной в большинстве случаев объявление переменной является также ее определением. 
\end{note}

\begin{example}
	Пример объявления без определения:
	
	\begin{verbatim}
		int g(int x);
	\end{verbatim}
\end{example}

\begin{note}
	Любое определение является объявлением, но не наоборот.
\end{note}

\begin{note}
	Объявлять можно сколько угодно раз. Определять - только один.
\end{note}

\begin{Verbatim}[tabsize=4]
	int x = 3;
	
	int main() {
		int x = 5;
	}
\end{Verbatim}

Это разные переменные $x$. При этом локальная <<затмевает>> глобальную. Можно создавать новый scope (область видимости) - просто написать $\{\}$.

\begin{Verbatim}[tabsize=4]
	int x = 3;
	int main() {
		int x = 5;
		{
			int x = 10;
		}
	}
\end{Verbatim}

В одной области видимости не может быть переменных с одним именем. По имени берется переменная лежащая в ближайшем области видимости.

Чтобы обратиться к глобальной переменной из любой области видимости нужно написать ::x.

\begin{Verbatim}[tabsize=4]
	int x = 3;
	int main() {
		int x = 5;
		cout << ::x << '\n'; \\ 3
	}
\end{Verbatim}

Обратиться к локальной переменной из другой области видимости, имеющее то же самое название, что и переменная из текущей области видимости невозможно.


\subsection{Namespace}
Способ разграничить области видимости.

\begin{Verbatim}[tabsize=4]
	namespace N {
		int x = 5;
		
		int f(int x);
		
		int f(int x) {
			return x + 1;
		}
	}
\end{Verbatim}

Namespace нельзя открывать внутри других сущностей, кроме других namespace. Чтобы обратиться к переменной namespace'a, нужно написать N::x.

Namespace можно открывать и закрывать сколько угодно раз. При повторном открытии namespace'a происходит добавление сущностей в него. Вне namespace'a можно определять его функции (если они не были определены раньше). При таком определении нужно обязательно объявить сущность внутри самого namespace'a.

Qualified-id - явно указано, откуда взята сущность (N::x).

\begin{Verbatim}[tabsize=4]
	using vi = std::vector<int>;
\end{Verbatim}

Грубо говоря, сокращение std::vector<int>. Но этот способ отличается от define'ов (define - потекстовая замена, как Ctrl+R). typedef - С-style способ.

\begin{Verbatim}[tabsize=4]
	using N::x;
\end{Verbatim}

Этой командой переменная x из namespace'a N переносится в текущую область видимости.

\begin{Verbatim}[tabsize=4]
	int main() {
		using N::x;
		int x = 5;
	}
\end{Verbatim}

Это ошибка!

\begin{Verbatim}[tabsize=4]
	using namespace N;
\end{Verbatim}

Перекидываются все сущности namespace'a. Плохая практика!


\subsection{Выражения и операторы}
\begin{Verbatim}[tabsize=4]
	a + 5; (--a * b << 3) + 1;
\end{Verbatim}

Это выражения (expressions). Их можно писать только внутри функций! Нельзя в глобальной области, в namespace и т.д.

Операторы:
\begin{itemize}
	\item Арифметические
	\item Побитовые
	\item Сравнения (since C++20, <=>)
	\item Логические
	\item Инкремент и декремент ($++x$ - префиксный, $x++$ - постфиксный)
	\item Присваивания	
\end{itemize}

Инкремент и декремент - единственные операторы, меняющие аргумент. Префиксный инкремент: возвращает уже увеличенное значение переменной (при этом возвращаемый тип - ссылка). Постфиксный возвращает прошлое значение переменной (только значение, не ссылка), но все равно увеличивает переменную.

\begin{example}
	
	\begin{Verbatim}[tabsize=4]
		 x++ && ++x = false, при x = 0 (после этой команды, x = 1)
	\end{Verbatim}
\end{example}

Присваивание возвращает ссылку на изменённую переменную.

\begin{note}
	
	\begin{Verbatim}[tabsize=4]
			x += 5;
			x = x + 5;
	\end{Verbatim}
\end{note}

Это на самом деле две разные команды. Первая сразу увеличивает переменную на 5. Вторая считает временное значение x + 5, потом присваивает это значение в x. Начиная на с C++17 гарантируется, что правая часть присваивания считается раньше левой. Например, ++x = x++. После этой команды x не изменится.

Присваивания выполняются справа-налево (x = y = 5, x = y += 5).
















